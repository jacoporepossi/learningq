{
  "hash": "bfa3ad96d9a8a25fcb06f1ae21a290e6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nlayout: post\ntitle: \"Object-oriented programming in Python: Classes - Part 1\"\ndate: 2022-05-28 11:06:00 +0100\ncategories: [Python Programming]\nimage: image.jpg\ndescription: |\n    Dive into the fundamentals of Python classes with this introductory guide, covering essential concepts with examples.\nkeywords: [python classes, object oriented programming in python]\n---\n\n## Introduction\nPython is an **object-oriented programming language** and therefore the emphasis is on objects. But what is an object?\n\nAn object is a **fundamental building block**: integers, strings, floats, dictionaries, are all objects and a class is a blueprint for that object.\n\nThink of a class as a sketch of a human body. We generally draw details of the shapes such as legs, arms, face etc and based on these characteristics we build the final drawing of a human body. We can create many versions starting from the same initial sketch: every version of a human body is called an instance of a class and the process of creating this object is called instantiation.\n\n## Aim of this notebook\n\nIn this first part we will explore the basics of classes in Python, with emphasis on the difference between **class and instance variables**, when to use them and how.\n\n## Classes and instances\n\nFirst of all, let's see the syntax to create a class in python.\n\n::: {#7177c87f .cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\n# Define a Pet class\nclass Pet():\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    # Create a class method that prints the Id of our Pet\n    def get_id(self):\n        print('My name is {} and I am {} yrs old'.format(self.name, self.age))\n\n# my_pet is an instance of the Pet class\nmy_pet = Pet('Bob', 3)\nmy_pet.get_id()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy name is Bob and I am 3 yrs old\n```\n:::\n:::\n\n\n```default\nMy name is Bob and I am 1 yrs old\n```\n    \n\nLet's now define some aspects of terminology when looking at the Pet class.\n\n`my_pet` is an **instance** of the Pet class, with `name` and `age` referred as **instance variables**. [Instance variables](https://docs.python.org/3/tutorial/classes.html#instance-objects) are variables that are owned by instances of the class.\n\n`__init__` or `get_id` are referred to as **methods** of the Pet class. In the example, the `__init__` method is called as soon as we create a new instance of the Pet class.\\\nMethods receive the **instance as first argument automatically**, each time we create methods within a class. By convention, the way to call the instance is with `self`.\nIn `get_id` we see that `self` is used to retrieve the instance variables `name` and `age`.\n\nAnother way to visualize `self` is by doing the following:\n\n::: {#0a9036ca .cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\n# my_pet.get_id() is the same as:\nPet.get_id(my_pet)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy name is Bob and I am 3 yrs old\n```\n:::\n:::\n\n\n```default\nMy name is Bob and I am 1 yrs old\n```\n\nAs we can see, the above line of code behaves the same as calling `my_pet.get_id()`. The only difference is that we are using the class `Pet`, calling the `get_id` method and passing the istance `my_pet`.\n\nLet's now prove that `name` and `age` are indeed instance variables:\n\n::: {#dcb6099d .cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\nmy_second_pet = Pet('Fido', 1)\nmy_second_pet.get_id()\n\n# my_pet still has its own name and age\nmy_pet.get_id()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy name is Fido and I am 1 yrs old\nMy name is Bob and I am 3 yrs old\n```\n:::\n:::\n\n\n```default\nMy name is Fido and I am 3 yrs old\nMy name is Bob and I am 1 yrs old\n```\n\nAs we can see, `name` and `age` are owned by each specific instance!\n\n## Class variables\n\nClass variables are defined within the class construction and because they are owned by the class itself, **they are shared by all instances** of the class.\n\n::: {#ac002d4a .cell execution_count=5}\n``` {.python .cell-code code-fold=\"false\"}\nclass Pet():\n    # Define a class variable that defines in which city my pets live\n    city_address = 'Milan'\n    \n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def get_id(self):\n        # I can access the class variable city_address either using Pet.city_address or with self.city_address\n        print('My name is {} and I am {} yrs old. I live in {}!'.format(self.name, self.age, self.city_address))\n\n# Let's create two instances of the Pet class\nmy_first_pet = Pet('Bob', 3)\nmy_second_pet = Pet('Fido', 1)\n\nprint(my_first_pet.city_address)\nprint(my_second_pet.city_address)\n\nmy_first_pet.get_id()\nmy_second_pet.get_id()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMilan\nMilan\nMy name is Bob and I am 3 yrs old. I live in Milan!\nMy name is Fido and I am 1 yrs old. I live in Milan!\n```\n:::\n:::\n\n\n```default\nMilan\nMilan\nMy name is Bob and I am 3 yrs old. I live in Milan!\nMy name is Fido and I am 1 yrs old. I live in Milan!\n```\n    \n\nAs we can see, since Bob and Fido are my two pets and given that my pets live with me, it makes sense to have a shared class variable.\\\nAs written in the code comment above, I can access the class attribute `city_address` either using `Pet.city_address` or with `self.city_address`. The latter might sound confusing, since we didn't specify any `self.city_address` in the `__init__` method. What's happening under the hood is that **Python is first checking if instance contains the variable, if it doesn't, it'll check if the class does**.\n\nTo better understand this, let's check the instance namespace and the class one\n\n::: {#a4008fc2 .cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\nprint(my_first_pet.__dict__)\nprint(Pet.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'name': 'Bob', 'age': 3}\n{'__module__': '__main__', 'city_address': 'Milan', '__init__': <function Pet.__init__ at 0x0000021E448D7740>, 'get_id': <function Pet.get_id at 0x0000021E448D7A60>, '__dict__': <attribute '__dict__' of 'Pet' objects>, '__weakref__': <attribute '__weakref__' of 'Pet' objects>, '__doc__': None}\n```\n:::\n:::\n\n\n```default\n{'name': 'Bob', 'age': 3}\n{'__module__': '__main__', 'city_address': 'Milan', '__init__': <function Pet.__init__ at 0x000001AE49139F70>, 'get_id': <function Pet.get_id at 0x000001AE491393A0>, '__dict__': <attribute '__dict__' of 'Pet' objects>, '__weakref__': <attribute '__weakref__' of 'Pet' objects>, '__doc__': None}\n```\n    \n\nAs we can see, the instance `my_first_pet` doesn't have the `city_address` attribute, whereas the class does (together with other stuff we don't care about now).\n\nLet's suppose now I change city where I live, moving to Rome.\n\n::: {#4df9cc54 .cell execution_count=7}\n``` {.python .cell-code code-fold=\"false\"}\nPet.city_address = 'Rome'\n\n# All the instances will inherit the new city_address.\nprint(my_first_pet.city_address)\nprint(my_second_pet.city_address)\n\nmy_first_pet.get_id()\nmy_second_pet.get_id()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRome\nRome\nMy name is Bob and I am 3 yrs old. I live in Rome!\nMy name is Fido and I am 1 yrs old. I live in Rome!\n```\n:::\n:::\n\n\n```default\nRome\nRome\nMy name is Bob and I am 3 yrs old. I live in Rome!\nMy name is Fido and I am 1 yrs old. I live in Rome!\n```\n    \n\nLet's suppose now that Fido stays in Milan with my family, how can we change that?\nThat's easy, we simply create the attribute `city_address` **within** the `Fido` instance \n\n::: {#a80c1eae .cell execution_count=8}\n``` {.python .cell-code code-fold=\"false\"}\nmy_second_pet.city_address = 'Milan'\n\n# Only Fido will have Milan\nprint(Pet.city_address)\nprint(my_first_pet.city_address)\nprint(my_second_pet.city_address)\nmy_first_pet.get_id()\nmy_second_pet.get_id()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRome\nRome\nMilan\nMy name is Bob and I am 3 yrs old. I live in Rome!\nMy name is Fido and I am 1 yrs old. I live in Milan!\n```\n:::\n:::\n\n\n```default\nRome\nRome\nMilan\nMy name is Bob and I am 3 yrs old. I live in Rome!\nMy name is Fido and I am 1 yrs old. I live in Milan!\n```\n\n::: {#7393eb1b .cell execution_count=9}\n``` {.python .cell-code code-fold=\"false\"}\n# This can be seen in \nprint(my_first_pet.__dict__)\nprint(my_second_pet.__dict__)\nprint(Pet.__dict__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'name': 'Bob', 'age': 3}\n{'name': 'Fido', 'age': 1, 'city_address': 'Milan'}\n{'__module__': '__main__', 'city_address': 'Rome', '__init__': <function Pet.__init__ at 0x0000021E448D7740>, 'get_id': <function Pet.get_id at 0x0000021E448D7A60>, '__dict__': <attribute '__dict__' of 'Pet' objects>, '__weakref__': <attribute '__weakref__' of 'Pet' objects>, '__doc__': None}\n```\n:::\n:::\n\n\n```default\n{'name': 'Bob', 'age': 3}\n{'name': 'Fido', 'age': 1, 'city_address': 'Milan'}\n{'__module__': '__main__', 'city_address': 'Rome', '__init__': <function Pet.__init__ at 0x000001AE49139F70>, 'get_id': <function Pet.get_id at 0x000001AE491393A0>, '__dict__': <attribute '__dict__' of 'Pet' objects>, '__weakref__': <attribute '__weakref__' of 'Pet' objects>, '__doc__': None}\n```\n    \n\nAll the above is happening because the we defined the get_id method using `self.city_address`\n> `print('My name is {} and I am {} yrs old. I live in {}!'.format(self.name, self.age, self.city_address))`\n\nShould it be always like that? What about `Pet.city_address`?\\\nAs we saw, it is convenient to have the flexibility of being able to change the city in which the Pet lives, so it makes sense to leave `self` in the method.\n\nLet's see what would happen if we changed to `Pet.city_address`\n\n::: {#d5adcccc .cell execution_count=10}\n``` {.python .cell-code code-fold=\"false\"}\nclass Pet():\n    # Define a class variable that defines in which city my pets live\n    city_address = 'Milan'\n    \n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def get_id(self):\n        print('My name is {} and I am {} yrs old. I live in {}!'.format(self.name, self.age, Pet.city_address))\n        \nmy_first_pet = Pet('Bob', 3)\nmy_second_pet = Pet('Fido', 1)\n\nmy_first_pet.get_id()\nmy_second_pet.get_id()\n\nPet.city_address = 'Rome'\nprint('\\nAFTER MOVING TO ROME')\n\nmy_first_pet.get_id()\nmy_second_pet.get_id()\n\nprint('\\nTRYING TO CHANGE CITY TO FIDO, NOT WORKING!')\nmy_second_pet.city_address = 'Milan'\nmy_first_pet.get_id()\nmy_second_pet.get_id()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy name is Bob and I am 3 yrs old. I live in Milan!\nMy name is Fido and I am 1 yrs old. I live in Milan!\n\nAFTER MOVING TO ROME\nMy name is Bob and I am 3 yrs old. I live in Rome!\nMy name is Fido and I am 1 yrs old. I live in Rome!\n\nTRYING TO CHANGE CITY TO FIDO, NOT WORKING!\nMy name is Bob and I am 3 yrs old. I live in Rome!\nMy name is Fido and I am 1 yrs old. I live in Rome!\n```\n:::\n:::\n\n\n    My name is Bob and I am 3 yrs old. I live in Milan!\n    My name is Fido and I am 1 yrs old. I live in Milan!\n    \n    AFTER MOVING TO ROME\n    My name is Bob and I am 3 yrs old. I live in Rome!\n    My name is Fido and I am 1 yrs old. I live in Rome!\n    \n    TRYING TO CHANGE CITY TO FIDO, NOT WORKING!\n    My name is Bob and I am 3 yrs old. I live in Rome!\n    My name is Fido and I am 1 yrs old. I live in Rome!\n    \n\nSince get_id works with `Pet.city_address`, creating the attribute `city_address = 'Milan'` within the instance `my_second_pet` doesn't affect the result, since we are still accessing the class variable!\n\nWhen would it make sense to use a class variable then?\\\nWhy not counting the number of pets I own each time I create a new instance of the Pet class?\n\n::: {#6beb7d27 .cell execution_count=11}\n``` {.python .cell-code code-fold=\"false\"}\nclass Pet():\n    city_address = 'Milan'\n    n_pets = 0\n    \n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        Pet.n_pets += 1\n    \n    def get_id(self):\n        print('My name is {} and I am {} yrs old. I live in {}!'.format(self.name, self.age, self.city_address))\n        \nprint('I own {} pets'.format(Pet.n_pets))\nmy_first_pet = Pet('Bob', 3)\nmy_second_pet = Pet('Fido', 1)\n\nprint('I now own {} pets'.format(Pet.n_pets))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI own 0 pets\nI now own 2 pets\n```\n:::\n:::\n\n\n    I own 0 pets\n    I now own 2 pets\n    \n\nCompared to `self.city_address`, now it's very unlikely that we are going to change the number of pets using an instance of the Pet class!\n\n## Conclusion\nIn this notebook we learned how to create a simple class and the difference between instance variables and class ones.\n\nIn [Part 2](https://jacoporepossi.github.io/learningq/python%20programming/2022/06/07/python-classes-part2.html), I'll explore static methods and class methods in details.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}